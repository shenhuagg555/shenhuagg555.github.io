<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>单位冲击函数基础</title>
      <link href="/2020/0518fad5.html"/>
      <url>/2020/0518fad5.html</url>
      
        <content type="html"><![CDATA[<h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><blockquote><script type="math/tex; mode=display">\delta_{\varepsilon}\left( t\right) =\left\{\begin{aligned}  0 & \ \ \ \ \ \ t<0 \\    \frac{1}{\varepsilon} & \ \ \ \ \ \ 0\le t\le \varepsilon\\    0 & \ \ \ \ \ \ t>\varepsilon\end{aligned}\right.</script><p><strong>若满足</strong> </p><script type="math/tex; mode=display">\underset{\varepsilon \rightarrow 0}{\lim}\int_{-\infty}^{+\infty}{\delta _{\varepsilon}\left( t \right) f\left( t \right)}dt=\int_{-\infty}^{+\infty}{\delta \left( t \right) f\left( t \right)}dt</script><p><strong>则称其为单位冲激函数</strong></p></blockquote><h2 id="性质1——归一性"><a href="#性质1——归一性" class="headerlink" title="性质1——归一性"></a>性质1——归一性</h2><blockquote><script type="math/tex; mode=display">\int_{-\infty}^{+\infty}{\delta\left( t \right)}dt=1</script></blockquote><h2 id="性质2——筛选性"><a href="#性质2——筛选性" class="headerlink" title="性质2——筛选性"></a>性质2——筛选性</h2><blockquote><script type="math/tex; mode=display">f\left( t \right) =\int_{-\infty}^{+\infty}{f\left( \tau \right) \delta\left( \tau -t \right)}d\tau</script><p><strong>特别地</strong></p><script type="math/tex; mode=display">\int_{-\infty}^{+\infty}{f\left( \tau \right) \delta \left( \tau \right)}d\tau =f\left( 0 \right)</script></blockquote><h2 id="性质3——奇偶性"><a href="#性质3——奇偶性" class="headerlink" title="性质3——奇偶性"></a>性质3——奇偶性</h2><blockquote><script type="math/tex; mode=display">\delta \left( t \right) =\delta \left( -t \right)</script></blockquote><h2 id="性质4——积分性质"><a href="#性质4——积分性质" class="headerlink" title="性质4——积分性质"></a>性质4——积分性质</h2><blockquote><script type="math/tex; mode=display">u\left( t \right) =\int_{-\infty}^t{\delta \left( \tau \right)}d\tau</script></blockquote><h2 id="性质5——微分性质"><a href="#性质5——微分性质" class="headerlink" title="性质5——微分性质"></a>性质5——微分性质</h2><blockquote><script type="math/tex; mode=display">\int_{-\infty}^{+\infty}{\delta ^{\left( n \right)}\left( t \right) f\left( t \right)}dt=\left( -1 \right) ^nf^{\left( n \right)}\left( 0 \right)</script><p><strong>特别地</strong></p><script type="math/tex; mode=display">\int_{-\infty}^{+\infty}{\delta '\left( t \right) f\left( t \right)}dt=-f'\left( 0 \right)</script></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Integral transform </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长递增子序列</title>
      <link href="/2020/0518c02f.html"/>
      <url>/2020/0518c02f.html</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><blockquote><p>给定一无序整数数组，求其最长递增子序列的长度。<br>例：输入 <code>[10,9,2,5,3,7,101,18]</code> 输出 <code>4</code></p></blockquote><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><blockquote><p>利用<code>dp</code>来做，我们考虑<code>dp[i]</code>为前<code>i+1</code>个数字最长递增子序列的长度，状态转移方程如下：</p><script type="math/tex; mode=display">dp\left[ i \right] =\max \left\{ dp\left[ i \right] ,\ dp\left[ j \right] +1 \right\} \ \ \ if\ \ nums\left[ i \right] \ >\ nums\left[ j \right] \ \left( 0\ \le \ j\ <\ i \right)</script><p>从而算出任意给定数组的最长递增子序列的长度。</p></blockquote><h2 id="cpp代码"><a href="#cpp代码" class="headerlink" title="cpp代码"></a>cpp代码</h2><pre><code>class solution{public:    int maxLength(vector&lt;int&gt; nums){        vector&lt;int&gt; dp(nums.size(), 1);        int maxl = 0;        for(int i  = 0; i &lt; nums.size(); i++){            for(int j = 0; j &lt; i; j++)                if(nums[i] &gt; nums[j])                    dp[i] = max(dp[i], dp[j]+1);            maxl = max(maxl, dp[i]);        }        return maxl;    }};</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><blockquote><p>时间复杂度 <code>O(n^2)</code><br>空间复杂度 <code>O(n)</code></p></blockquote><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><blockquote><p><code>dp</code>来做还行，但时间复杂度稍高，有大神给出了二分查找解法，其时间复杂度仅为<code>O(nlogn)</code>，一般人确实想不到，有机会再聊聊二分查找。</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Data structure and algorithm </tag>
            
            <tag> dp动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无重复数字</title>
      <link href="/2020/0517ff7b.html"/>
      <url>/2020/0517ff7b.html</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><blockquote><p>对于给定数组<code>nums</code>,寻找数组中无重复的数字，假定此数字唯一，且重复数字仅出现两次。<br>例如：给定<code>nums = [1, 2, 3, 1, 2, 3, 4]</code>  ，则  <code>res = 4</code></p></blockquote><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><blockquote><p>此题主要考察异或<code>^</code>的用法，我们知道对于任意数<code>n</code>有以下性质 ：<br><code>n ^ n = 0</code><br><code>0 ^ n = n</code><br>知道有这样的性质后，结合题意，我们可以想到将数组中所有元素异或的结果即为所求。</p></blockquote><h2 id="cpp代码"><a href="#cpp代码" class="headerlink" title="cpp代码"></a>cpp代码</h2><pre><code>class solution{public:    int func(vector&lt;int&gt; &amp;nums){        int res = nums[0];        for(int i = 1; i &lt; nums.size(); i++)            res ^= nums[i];        return res;    }}；</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><blockquote><p>时间复杂度 <code>O(n)</code><br>空间复杂度 <code>O(1)</code></p></blockquote><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><blockquote><p>对于出现两次(或者偶数次的重复数可以采用异或)，但若是未交代重复次数，则一般利用<code>hash</code>,这样的话空间复杂度则会变成<code>O(n)</code>,但也无伤大雅。</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Data structure and algorithm </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laplace变换基础</title>
      <link href="/2020/0516b659.html"/>
      <url>/2020/0516b659.html</url>
      
        <content type="html"><![CDATA[<h2 id="Laplace变换定义"><a href="#Laplace变换定义" class="headerlink" title="Laplace变换定义"></a>Laplace变换定义</h2><blockquote><p>$f\left( x \right)$在$t\ge 0$有定义，且积分</p><script type="math/tex; mode=display">\int_0^{+\infty}{f\left( t \right) e^{-st}}dt\ \ \left( s\text{为复数} \right)</script><p>在s的某一区域内收敛，则称</p><script type="math/tex; mode=display">F\left( s \right) =\int_0^{+\infty}{f\left( t \right) e^{-st}}dt</script><p>为$f\left( t \right)$的Laplace变换式，记为$F\left( s \right) =\mathscr{L}\left[ f\left( t \right) \right]$</p></blockquote><h2 id="周期函数的Laplace变换"><a href="#周期函数的Laplace变换" class="headerlink" title="周期函数的Laplace变换"></a>周期函数的Laplace变换</h2><blockquote><p>对于一个以$T$为周期的函数$f\left( t \right)$ ，当$f\left( t \right)$在一个周期上分段连续时，有</p><script type="math/tex; mode=display">\mathscr{L}\left[ f\left( t \right) \right] =\frac{1}{1-e^{-sT}}\int_0^T{f\left( t \right) e^{-st}}dt\ \ \ \ \ \ \text{其中Re}s\left( s \right) >0</script></blockquote><h2 id="Laplace变换性质"><a href="#Laplace变换性质" class="headerlink" title="Laplace变换性质"></a>Laplace变换性质</h2><blockquote><p>1.线性性质</p><script type="math/tex; mode=display">\mathscr{L}\left[ \alpha f_1\left( t \right) +\beta f_2\left( t \right) \right] =\alpha \mathscr{L}\left[ f_1\left( t \right) \right] +\beta \mathscr{L}\left[ f_2\left( t \right) \right]</script><p>2.微分性质<br>（1）象原函数的微分性质<br>设$\mathscr{L}\left[ f\left( t \right) \right] =F\left( s \right)$</p><script type="math/tex; mode=display">\mathscr{L}\left[ f^{\left( n \right)}\left( t \right) \right] =s^nF\left( s \right) -\sum_{i=0}^{n-1}{s^{n-1-i}f^{\left( i \right)}\left( 0 \right)}\ \ \ \text{Re}s\left( s \right) >c</script><p>（2）象函数的微分性质<br>设$\mathscr{L}\left[ f\left( t \right) \right] =F\left( s \right)$</p><script type="math/tex; mode=display">F^{\left( n \right)}\left( s \right) =\left( -1 \right) ^n\mathscr{L}\left[ t^nf\left( t \right) \right] \ \ \ \ \text{Re}s\left( s \right) >c</script><p>3.积分性质</p><p>(1）象原函数的积分性质<br>设$\mathscr{L}\left[ f\left( t \right) \right] =F\left( s \right)$</p><script type="math/tex; mode=display">\mathscr{L}\left[ \int_0^t{f\left( t \right)}dt \right] =\frac{1}{s}F\left( s \right)</script><p>（2）象函数的积分性质<br>设$\mathscr{L}\left[ f\left( t \right) \right] =F\left( s \right)$</p><script type="math/tex; mode=display">\mathscr{L}\left[ \frac{f\left( t \right)}{t} \right] =\int_s^{+\infty}{F\left( s \right)}ds</script><p>一般地，有</p><script type="math/tex; mode=display">\mathscr{L}\left[ \frac{f\left( t \right)}{t^n} \right] =\underset{n\text{次积分}}{\underbrace{\int_s^{+\infty}{\int_s^{+\infty}{...\int_s^{+\infty}{F\left( s \right)}ds}}}}</script><p>4.位移性质<br>设$\mathscr{L}\left[ f\left( t \right) \right] =F\left( s \right)$,则有</p><script type="math/tex; mode=display">\mathscr{L}\left[ e^{at}f\left( t \right) \right] =F\left( s-a \right) \ \</script><p>5.延迟性质<br>设$\mathscr{L}\left[ f\left( t \right) \right] =F\left( s \right) \text{，}t&lt;0$时，$f\left( t \right) =0$，则对于任意非负实数$\tau$，有</p><script type="math/tex; mode=display">\mathscr{L}\left[ f\left( t-\tau \right) \right] =e^{-s\tau}F\left( s \right)</script></blockquote><h2 id="Laplace逆变换的求法"><a href="#Laplace逆变换的求法" class="headerlink" title="Laplace逆变换的求法"></a>Laplace逆变换的求法</h2><blockquote><p>定理1（留数):<br>$s_i\left( i=1,2,,,n \right)$是函数$F\left( s \right)$的所有奇点,且当$s\rightarrow \infty$时$,F\left( s \right) \rightarrow 0$,则有</p><script type="math/tex; mode=display">f\left( t \right) =\sum_{k=1}^n{\text{Re}s\left[ F\left( s \right) e^{st},s_k \right]}\ \ \ t>0</script><p>定理2（卷积):<br>若函数$f_1\left( t \right)$和$f_2\left( t \right)$满足Laplace变换存在定理中的条件,且$\mathscr{L}\left[ f_1\left( t \right) \right] =F_1\left( s \right) \mathscr{L}\left[ f_2\left( t \right) \right] =F_2\left( s \right)$ ,则$f_1\left( t \right) \ast f_2\left( t \right)&gt;$的Laplce变换一定存在，则</p><script type="math/tex; mode=display">\mathscr{L}\left[ f_1\left( t \right) \ast f_2\left( t \right) \right] =\mathscr{L}\left[ f_1\left( t \right) \right] \cdot \mathscr{L}\left[ f_2\left( t \right) \right] =F_1\left( s \right) \cdot F_2\left( s \right)</script><p>这个性质表明两个函数卷积的Laplace变换等于这两个函数Laplace变换乘积</p><p>卷积定义：<br>设有两个函数$f_1\left( t \right) ,f_2\left( t \right)$ ,称积分</p><script type="math/tex; mode=display">f_1\left( t \right) \ast f_2\left( t \right) =\int_{-\infty}^{+\infty}{f_1\left( \tau \right) f_2\left( t-\tau \right)}d\tau</script><p>为函数$f_1\left( x \right) ,f_2\left( x \right)$的卷积</p><p>若函数$f_1\left( t \right) ,f_2\left( t \right)$满足：当$t&lt;0$时，$f_1\left( t \right) =f_2\left( t \right) =0$,则有</p><script type="math/tex; mode=display">f_1\left( t \right) \ast f_2\left( t \right) =\int_0^t{f_1\left( \tau \right) f_2\left( t-\tau \right)}d\tau</script></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Integral transform </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表分离奇偶节点</title>
      <link href="/2020/05164341.html"/>
      <url>/2020/05164341.html</url>
      
        <content type="html"><![CDATA[<h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><blockquote><p>函数<code>readlist</code>从标准输入读入一系列正整数，按照读入顺序建立单链表。当读到<code>−1</code>时表示输入结束，函数应返回指向单链表头结点的指针。</p><p>函数<code>getodd</code>将单链表<code>L</code>中奇数值的结点分离出来，重新组成一个新的链表。返回指向新链表头指针，同时将<code>L</code>改为删除了奇数值结点后的链表的头指针</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>函数<code>readlist</code>不必说，就是一层循环，判断输入是否为<code>-1</code>,返回头指针。</p><p>函数<code>getodd</code>首先创建奇链表的头指针<code>jList</code>，遍历创建好的链表，遇到奇数节点，利用尾插法将奇数节点链接在<code>jList</code>上，偶数节点时，创建一个临时指针保存当前节点（遇到奇数节点时，临时指针就是当前节点的前序节点，原链表可以跨过此节点）。</p></blockquote><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre class=" language-lang-c"><code class="language-lang-c">struct ListNode *creatNode(int x){    struct ListNode *p = (struct ListNode *)malloc(sizeof(struct ListNode));    p->data = x;    p->next = NULL;    return p;}struct ListNode *readlist(){    int x;    scanf("%d", &x);    struct ListNode *head = creatNode(x);    struct ListNode *pre = head;    scanf("%d", &x);    while(x != -1){        struct ListNode *p = creatNode(x);        pre->next = p;        pre = p;        scanf("%d", &x);    }    return head;}struct ListNode *getodd( struct ListNode **L ){    struct ListNode *jList = (struct ListNode *)malloc(sizeof(struct ListNode));    jList->next = NULL;    struct ListNode *jpre = jList;    while(*L && (*L)->data % 2 == 1){        jpre->next = *L;        jpre = jpre->next;        *L = (*L)->next;    }    struct ListNode *oList = *L;    struct ListNode *opre = oList;    while (oList) {        if (oList->data % 2 == 1) {            jpre->next = oList;            jpre = jpre->next;            opre->next = oList->next;            oList = oList->next;        }        else {            opre = oList;            oList = oList->next;        }    }    jpre->next = NULL;    return jList->next;}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Data structure and algorithm </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
