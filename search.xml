<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>BinarySearch</title>
      <link href="/2020/06101457.html"/>
      <url>/2020/06101457.html</url>
      
        <content type="html"><![CDATA[<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><blockquote><p>二分查找老生常谈了，有<code>循环</code>的写法，也有<code>递归</code>的写法，随便写写吧。</p></blockquote><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><pre class=" language-lang-c++"><code class="language-lang-c++">int BinarySearch(int arr[], int len, int x){    int left = 0;    int right = len-1;    while(left <= right){        int mid = (left + right) / 2;        if(x == arr[mid])            return mid;        else if(x > arr[mid])            left = mid + 1;        else            right = mid - 1;    }    return -1;}</code></pre><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><pre class=" language-lang-c++"><code class="language-lang-c++">int BSearch(int arr[], int L, int R, int x){    int mid = (L + R) / 2;    if(arr[mid] < x)        return BSearch(arr, mid + 1, R, x);    else if(arr[mid] > x)        return BSearch(arr, L, mid - 1, x);    else        return mid;    return -1;}</code></pre><h3 id="一行"><a href="#一行" class="headerlink" title="一行"></a>一行</h3><pre class=" language-lang-c++"><code class="language-lang-c++">int bSearch(int arr[], int L, int R, int x){    return arr[L] <= x && arr[R] >= x ? (arr[(L+R)/2] < x ? bSearch(arr, (L+R)/2 + 1, R, x) : (arr[(L+R)/2] > x ? bSearch(arr, L, (L+R)/2 - 1, x) : (L+R)/2)) : -1;}</code></pre><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><blockquote><p>当然不建议最后一个方法，它的可读性差，没啥鸟用。</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Data structure and algorithm </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表常用操作</title>
      <link href="/2020/0531fedc.html"/>
      <url>/2020/0531fedc.html</url>
      
        <content type="html"><![CDATA[<h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><blockquote><p>如：<code>创建</code>、<code>插入</code>、<code>删除</code>、<code>销毁</code>、<code>打印</code>等。</p></blockquote><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><blockquote><p>对于带有<code>头指针</code>的单链表，在<code>创建</code>、<code>插入</code>、<code>删除</code>、<code>销毁</code>(可能需要修改<code>头指针</code>)时，都需要传入<code>头指针的引用</code>(或<code>头指针的指针</code>)。</p><p><code>插入</code>节点时，需要向<code>内存</code>申请一片<code>空间</code>。</p><p><code>删除</code>节点时，需要将被删除节点的<code>空间</code>还给<code>内存</code>。</p><p><code>销毁</code>链表时，销毁成功后需要将<code>头指针</code>再次<code>置空</code>。</p></blockquote><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre class=" language-lang-c++"><code class="language-lang-c++">typedef struct ListNode{    int data;    struct ListNode *next;}ListNode;ListNode* initList(ListNode* &L){             //初始化头指针为NULL    L = NULL;    return L;}int lengthList(ListNode* L){                  //获取单链表的长度    int len = 0;    ListNode *p = L;;    while(p){        len++;        p = p->next;    }    return len;}bool isEmpty(ListNode* L){                    //判断链表是否为空    return L == NULL;}ListNode* creatNode(int x){                   //创建一个节点并赋值    ListNode * p = new ListNode;    p->next =NULL;    p->data = x;    return p;}void deleteNode(ListNode *p){                 //删除一个节点    delete p;}ListNode* searchNode(ListNode* L, int k){     //查找某个节点    ListNode *p = L;    if(isEmpty(L))        return NULL;    else{        int len = lengthList(L);        if(k > len || k <= 0)          //不在查找范围内            return NULL;        else{                          //允许查找            int index = 1;            while(index != k){                index++;                p= p->next;            }            return p;        }    }}bool insertNode(ListNode* &L, int k, int x){             //插入一个节点    ListNode *p = searchNode(L, k-1);    ListNode *t = creatNode(x);    if(k == 1){                          //当插入位置在首位时，需要修改头指针，所以这里传的时指针的引用(当然头指针的指针也可)        t->next = L;        L = t;        return true;    }    else{        if(p != NULL){                  //当可以查询到插入前一位置时(k != 1)，此时先栓新链，再解旧链            t->next = p->next;            p->next = t;            return true;        }        else            return false;    }}bool removeNode(ListNode* &L, int k, int &x){           //删除一个节点并保存其值    ListNode *p = searchNode(L, k-1);    if(L != NULL){        if(k == 1){                   //当删除首个节点时，需要修改头指针，同样要传头指针的引用            x = L->data;            ListNode *t = L;            L = L->next;            deleteNode(t);            return true;        }        else{            if(p != NULL){                //当可以查询到删除前一位置时，同样拴住新绳，再将旧绳连起来                ListNode *t = p->next;                x = t->data;                p->next = t->next;                deleteNode(t);                return true;            }            else                return false;        }    }    else        return false;}bool destoryList(ListNode* &L){            //销毁整个单链表    if(!isEmpty(L)){        ListNode *p = L;        ListNode *t = L->next;        while(p){            deleteNode(p);            p = t;            if(t)                t = t->next;        }        L = NULL;                        //销毁成功后，将头指针再次置空        return true;    }    else        return false;}void printList(ListNode* L){             //打印单链表    ListNode *p = L;    while(p){        cout << p->data << endl;        p = p->next;    }}</code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><blockquote><p><code>数据结构</code>怎么说呢，我觉得还是<code>实践出真知</code>吧！越<code>敲</code>你就会发现<code>BUG</code>越多，然后慢慢地你就越来越<code>叼</code>了(\坏笑)。</p><p><code>链表</code>的原理烂熟于心了，什么<code>栈</code>、<code>队列</code>的链式实现(<code>阉割版链表</code>)还不是手到擒来吗？</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Data structure and algorithm </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串匹配算法</title>
      <link href="/2020/05204714.html"/>
      <url>/2020/05204714.html</url>
      
        <content type="html"><![CDATA[<h2 id="BP暴力搜索"><a href="#BP暴力搜索" class="headerlink" title="BP暴力搜索"></a>BP暴力搜索</h2><h3 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h3><blockquote><p>匹配串<code>S</code>和模式串<code>T</code>从头开始比较即初始化<code>i = 0, j = 0</code>，当<code>S[i] == T[j]</code>时，将两串下标同时右移，反之，则将匹配串<code>S</code>回溯到当前匹配开头的下一位，模式串则回到<code>j = 0</code>。当<code>j = strlen(T)</code>时，匹配成功，当<code>i = strlen(S)</code>，则匹配失败，传入下标<code>index</code>的引用，初始化为<code>-1</code>，匹配成功时，修改为模式串<code>T</code>在匹配串<code>S</code>中的下标。</p></blockquote><h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><pre><code>bool BP(char *S, char *T, int &amp;index){    int i = 0, j = 0;    int S_len = strlen(S);    int T_len = strlen(T);    while(i != S_len || j != T_len){        if(S[i] == T[j]){            i++;            j++;        }        else{            i -= (j-1);            j = 0;        }    }    if(j == T_len){        index = i - j;        return true;    }    else        return false;}</code></pre><h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><h3 id="算法概述-1"><a href="#算法概述-1" class="headerlink" title="算法概述"></a>算法概述</h3><blockquote><p>针对BP算法的大量无用回溯，KMP算法利用已匹配的信息，创建<code>next</code>数组记录<strong>当前匹配位置之前前缀和后缀相同的最长字串长度</strong>，这样一来，对于匹配串<code>S</code>就可以回溯至后缀字串的位置，充分利用首次匹配的信息。</p><p>对于<code>next</code>数组的求解，我先放出代码，然后结合代码具体分析。</p></blockquote><h3 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h3><pre><code>void getNext(char *T, int *next){    int j = -1, i = 0;                   //定义前缀j,后缀i    next[0] = -1;                        //赋初值-1，代表不参与匹配    int T_len = strlen(T);    while(i != T_len){        if(j = -1 || T[i] == T[j]){      //当前缀与后缀相等，则i+1的next数组的值即为j+1            i++;            j++;            next[i] = j;        }        else                             //j回退到前缀匹配的最大长度            j = next[j];    }}bool KMP(char *S, char *T, int &amp;index){    int i = 0, j = 0;    int S_len = strlen(S);    int T_len = strlen(T);    int *next;    getNext(T, next);    while(i != S_len || j != T_len){        if(j = -1 || S[i] == T[j]){            i++;            j++;        }        else            j = next[j];    }    if(j = T_len){        index = i - j;        return true;    }    else        return false;}</code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><blockquote><p>KMP算法的精华之处在于维护一个<code>next</code>数组,使得匹配串无需多次回溯，当然KMP算法也有很多缺点，下次可以讲讲KMP算法的改进。</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> BP算法 </tag>
            
            <tag> KMP算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TwoSum问题</title>
      <link href="/2020/0519e8cb.html"/>
      <url>/2020/0519e8cb.html</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><blockquote><p>给定一个整数数组<code>nums</code>和一个目标值<code>target</code>,请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。<br>你可以假设每种输入只会对应一个答案。但数组中同一个元素不能使用两遍。<br>例：给定 <code>nums = [2, 7, 11, 15]</code>, <code>target = 9</code>， 返回<code>[0, 1]</code></p></blockquote><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><blockquote><p>可以通过暴力法两层循环，但显然此法时间复杂度为<code>O(n^2)</code>，通过分析利用哈希表是很好的处理方法，它的查找时间是<code>O(1)</code>。</p></blockquote><h2 id="cpp代码"><a href="#cpp代码" class="headerlink" title="cpp代码"></a>cpp代码</h2><pre><code>class Solution {public:    vector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;nums, int target) {        unordered_map&lt;int, int&gt; hmap;        for(int i = 0; i &lt; nums.size(); i++){            if(hmap.find(target-nums[i]) != hmap.end())                return {hmap[target-nums[i]] , i};            hmap[nums[i]] = i;        }        return {};    }};</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><blockquote><p>时间复杂度 <code>O(n)</code><br>空间复杂度 <code>O(n)</code></p></blockquote><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><blockquote><p>此题摘自Leetcode第1题，新手玩家可以利用暴力法得出答案，而哈希表也应当是大家思考后能快速想出的办法，多刷题还是有很大帮助的！！！</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Data structure and algorithm </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单位冲击函数基础</title>
      <link href="/2020/0518fad5.html"/>
      <url>/2020/0518fad5.html</url>
      
        <content type="html"><![CDATA[<h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><blockquote><script type="math/tex; mode=display">\delta_{\varepsilon}\left( t\right) =\left\{\begin{aligned}  0 & \ \ \ \ \ \ t<0 \\    \frac{1}{\varepsilon} & \ \ \ \ \ \ 0\le t\le \varepsilon\\    0 & \ \ \ \ \ \ t>\varepsilon\end{aligned}\right.</script><p><strong>若满足</strong> </p><script type="math/tex; mode=display">\underset{\varepsilon \rightarrow 0}{\lim}\int_{-\infty}^{+\infty}{\delta _{\varepsilon}\left( t \right) f\left( t \right)}dt=\int_{-\infty}^{+\infty}{\delta \left( t \right) f\left( t \right)}dt</script><p><strong>则称其为单位冲激函数</strong></p></blockquote><h2 id="性质1——归一性"><a href="#性质1——归一性" class="headerlink" title="性质1——归一性"></a>性质1——归一性</h2><blockquote><script type="math/tex; mode=display">\int_{-\infty}^{+\infty}{\delta\left( t \right)}dt=1</script></blockquote><h2 id="性质2——筛选性"><a href="#性质2——筛选性" class="headerlink" title="性质2——筛选性"></a>性质2——筛选性</h2><blockquote><script type="math/tex; mode=display">f\left( t \right) =\int_{-\infty}^{+\infty}{f\left( \tau \right) \delta\left( \tau -t \right)}d\tau</script><p><strong>特别地</strong></p><script type="math/tex; mode=display">\int_{-\infty}^{+\infty}{f\left( \tau \right) \delta \left( \tau \right)}d\tau =f\left( 0 \right)</script></blockquote><h2 id="性质3——奇偶性"><a href="#性质3——奇偶性" class="headerlink" title="性质3——奇偶性"></a>性质3——奇偶性</h2><blockquote><script type="math/tex; mode=display">\delta \left( t \right) =\delta \left( -t \right)</script></blockquote><h2 id="性质4——积分性质"><a href="#性质4——积分性质" class="headerlink" title="性质4——积分性质"></a>性质4——积分性质</h2><blockquote><script type="math/tex; mode=display">u\left( t \right) =\int_{-\infty}^t{\delta \left( \tau \right)}d\tau</script></blockquote><h2 id="性质5——微分性质"><a href="#性质5——微分性质" class="headerlink" title="性质5——微分性质"></a>性质5——微分性质</h2><blockquote><script type="math/tex; mode=display">\int_{-\infty}^{+\infty}{\delta ^{\left( n \right)}\left( t \right) f\left( t \right)}dt=\left( -1 \right) ^nf^{\left( n \right)}\left( 0 \right)</script><p><strong>特别地</strong></p><script type="math/tex; mode=display">\int_{-\infty}^{+\infty}{\delta '\left( t \right) f\left( t \right)}dt=-f'\left( 0 \right)</script></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Integral transform </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长递增子序列</title>
      <link href="/2020/0518c02f.html"/>
      <url>/2020/0518c02f.html</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><blockquote><p>给定一无序整数数组，求其最长递增子序列的长度。<br>例：输入 <code>[10,9,2,5,3,7,101,18]</code> 输出 <code>4</code></p></blockquote><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><blockquote><p>利用<code>dp</code>来做，我们考虑<code>dp[i]</code>为前<code>i+1</code>个数字最长递增子序列的长度，状态转移方程如下：</p><script type="math/tex; mode=display">dp\left[ i \right] =\max \left\{ dp\left[ i \right] ,\ dp\left[ j \right] +1 \right\} \ \ \ if\ \ nums\left[ i \right] \ >\ nums\left[ j \right] \ \left( 0\ \le \ j\ <\ i \right)</script><p>从而算出任意给定数组的最长递增子序列的长度。</p></blockquote><h2 id="cpp代码"><a href="#cpp代码" class="headerlink" title="cpp代码"></a>cpp代码</h2><pre><code>class Solution{public:    int maxLength(vector&lt;int&gt; nums){        vector&lt;int&gt; dp(nums.size(), 1);        int maxl = 0;        for(int i  = 0; i &lt; nums.size(); i++){            for(int j = 0; j &lt; i; j++)                if(nums[i] &gt; nums[j])                    dp[i] = max(dp[i], dp[j]+1);            maxl = max(maxl, dp[i]);        }        return maxl;    }};</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><blockquote><p>时间复杂度 <code>O(n^2)</code><br>空间复杂度 <code>O(n)</code></p></blockquote><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><blockquote><p><code>dp</code>来做还行，但时间复杂度稍高，有大神给出了二分查找解法，其时间复杂度仅为<code>O(nlogn)</code>，一般人确实想不到，有机会再聊聊二分查找。</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Data structure and algorithm </tag>
            
            <tag> dp动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无重复数字</title>
      <link href="/2020/0517ff7b.html"/>
      <url>/2020/0517ff7b.html</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><blockquote><p>对于给定数组<code>nums</code>,寻找数组中无重复的数字，假定此数字唯一，且重复数字仅出现两次。<br>例如：给定<code>nums = [1, 2, 3, 1, 2, 3, 4]</code>  ，则  <code>res = 4</code></p></blockquote><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><blockquote><p>此题主要考察异或<code>^</code>的用法，我们知道对于任意数<code>n</code>有以下性质 ：<br><code>n ^ n = 0</code><br><code>0 ^ n = n</code><br>知道有这样的性质后，结合题意，我们可以想到将数组中所有元素异或的结果即为所求。</p></blockquote><h2 id="cpp代码"><a href="#cpp代码" class="headerlink" title="cpp代码"></a>cpp代码</h2><pre><code>class Solution{public:    int func(vector&lt;int&gt; &amp;nums){        int res = nums[0];        for(int i = 1; i &lt; nums.size(); i++)            res ^= nums[i];        return res;    }}；</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><blockquote><p>时间复杂度 <code>O(n)</code><br>空间复杂度 <code>O(1)</code></p></blockquote><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><blockquote><p>对于出现两次(或者偶数次的重复数可以采用异或)，但若是未交代重复次数，则一般利用<code>hash</code>,这样的话空间复杂度则会变成<code>O(n)</code>,但也无伤大雅。</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Data structure and algorithm </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laplace变换基础</title>
      <link href="/2020/0516b659.html"/>
      <url>/2020/0516b659.html</url>
      
        <content type="html"><![CDATA[<h2 id="一-Laplace变换定义"><a href="#一-Laplace变换定义" class="headerlink" title="一.Laplace变换定义"></a>一.Laplace变换定义</h2><blockquote><p>$f\left( x \right)$在$t\ge 0$有定义，且积分</p><script type="math/tex; mode=display">\int_0^{+\infty}{f\left( t \right) e^{-st}}dt\ \ \left( s\text{为复数} \right)</script><p>在s的某一区域内收敛，则称</p><script type="math/tex; mode=display">F\left( s \right) =\int_0^{+\infty}{f\left( t \right) e^{-st}}dt</script><p>为$f\left( t \right)$的Laplace变换式，记为$F\left( s \right) =\mathscr{L}\left[ f\left( t \right) \right]$</p></blockquote><h2 id="二-周期函数的Laplace变换"><a href="#二-周期函数的Laplace变换" class="headerlink" title="二.周期函数的Laplace变换"></a>二.周期函数的Laplace变换</h2><blockquote><p>对于一个以$T$为周期的函数$f\left( t \right)$ ，当$f\left( t \right)$在一个周期上分段连续时，有</p><script type="math/tex; mode=display">\mathscr{L}\left[ f\left( t \right) \right] =\frac{1}{1-e^{-sT}}\int_0^T{f\left( t \right) e^{-st}}dt\ \ \ \ \ \ \text{其中Re}s\left( s \right) >0</script></blockquote><h2 id="三-Laplace变换性质"><a href="#三-Laplace变换性质" class="headerlink" title="三.Laplace变换性质"></a>三.Laplace变换性质</h2><h3 id="1-线性性质"><a href="#1-线性性质" class="headerlink" title="1.线性性质"></a>1.线性性质</h3><blockquote><script type="math/tex; mode=display">\mathscr{L}\left[ \alpha f_1\left( t \right) +\beta f_2\left( t \right) \right] =\alpha \mathscr{L}\left[ f_1\left( t \right) \right] +\beta \mathscr{L}\left[ f_2\left( t \right) \right]</script></blockquote><h3 id="2-微分性质"><a href="#2-微分性质" class="headerlink" title="2.微分性质"></a>2.微分性质</h3><blockquote><p>（1）象原函数的微分性质<br>设$\mathscr{L}\left[ f\left( t \right) \right] =F\left( s \right)$</p><script type="math/tex; mode=display">\mathscr{L}\left[ f^{\left( n \right)}\left( t \right) \right] =s^nF\left( s \right) -\sum_{i=0}^{n-1}{s^{n-1-i}f^{\left( i \right)}\left( 0 \right)}\ \ \ \text{Re}s\left( s \right) >c</script><p>（2）象函数的微分性质<br>设$\mathscr{L}\left[ f\left( t \right) \right] =F\left( s \right)$</p><script type="math/tex; mode=display">F^{\left( n \right)}\left( s \right) =\left( -1 \right) ^n\mathscr{L}\left[ t^nf\left( t \right) \right] \ \ \ \ \text{Re}s\left( s \right) >c</script></blockquote><h3 id="3-积分性质"><a href="#3-积分性质" class="headerlink" title="3.积分性质"></a>3.积分性质</h3><blockquote><p>(1）象原函数的积分性质<br>设$\mathscr{L}\left[ f\left( t \right) \right] =F\left( s \right)$</p><script type="math/tex; mode=display">\mathscr{L}\left[ \int_0^t{f\left( t \right)}dt \right] =\frac{1}{s}F\left( s \right)</script><p>（2）象函数的积分性质<br>设$\mathscr{L}\left[ f\left( t \right) \right] =F\left( s \right)$</p><script type="math/tex; mode=display">\mathscr{L}\left[ \frac{f\left( t \right)}{t} \right] =\int_s^{+\infty}{F\left( s \right)}ds</script><p>一般地，有</p><script type="math/tex; mode=display">\mathscr{L}\left[ \frac{f\left( t \right)}{t^n} \right] =\underset{n\text{次积分}}{\underbrace{\int_s^{+\infty}{\int_s^{+\infty}{...\int_s^{+\infty}{F\left( s \right)}ds}}}}</script></blockquote><h3 id="4-位移性质"><a href="#4-位移性质" class="headerlink" title="4.位移性质"></a>4.位移性质</h3><blockquote><p>设$\mathscr{L}\left[ f\left( t \right) \right] =F\left( s \right)$,则有</p><script type="math/tex; mode=display">\mathscr{L}\left[ e^{at}f\left( t \right) \right] =F\left( s-a \right) \ \</script></blockquote><h3 id="5-延迟性质"><a href="#5-延迟性质" class="headerlink" title="5.延迟性质"></a>5.延迟性质</h3><blockquote><p>设$\mathscr{L}\left[ f\left( t \right) \right] =F\left( s \right) \text{，}t&lt;0$时，$f\left( t \right) =0$，则对于任意非负实数$\tau$，有</p><script type="math/tex; mode=display">\mathscr{L}\left[ f\left( t-\tau \right) \right] =e^{-s\tau}F\left( s \right)</script></blockquote><h3 id="6-初值定理"><a href="#6-初值定理" class="headerlink" title="6.初值定理"></a>6.初值定理</h3><blockquote><script type="math/tex; mode=display">\underset{t\rightarrow 0}{\lim}f\left( t \right) =\underset{s\rightarrow +\infty}{\lim}sF\left( s \right)</script></blockquote><h3 id="7-终值定理"><a href="#7-终值定理" class="headerlink" title="7.终值定理"></a>7.终值定理</h3><blockquote><script type="math/tex; mode=display">\underset{t\rightarrow +\infty}{\lim}f\left( t \right) =\underset{s\rightarrow 0}{\lim}sF\left( s \right)</script></blockquote><h2 id="四-Laplace逆变换的求法"><a href="#四-Laplace逆变换的求法" class="headerlink" title="四.Laplace逆变换的求法"></a>四.Laplace逆变换的求法</h2><h3 id="定理1（留数"><a href="#定理1（留数" class="headerlink" title="定理1（留数):"></a>定理1（留数):</h3><blockquote><p>$s_i\left( i=1,2,,,n \right)$是函数$F\left( s \right)$的所有奇点,且当$s\rightarrow \infty$时$,F\left( s \right) \rightarrow 0$,则有</p><script type="math/tex; mode=display">f\left( t \right) =\sum_{k=1}^n{\text{Re}s\left[ F\left( s \right) e^{st},s_k \right]}\ \ \ t>0</script></blockquote><h3 id="定理2（卷积"><a href="#定理2（卷积" class="headerlink" title="定理2（卷积):"></a>定理2（卷积):</h3><blockquote><p>若函数$f_1\left( t \right)$和$f_2\left( t \right)$满足Laplace变换存在定理中的条件,且$\mathscr{L}\left[ f_1\left( t \right) \right] =F_1\left( s \right) \mathscr{L}\left[ f_2\left( t \right) \right] =F_2\left( s \right)$ ,则$f_1\left( t \right) \ast f_2\left( t \right)&gt;$的Laplce变换一定存在，则</p><script type="math/tex; mode=display">\mathscr{L}\left[ f_1\left( t \right) \ast f_2\left( t \right) \right] =\mathscr{L}\left[ f_1\left( t \right) \right] \cdot \mathscr{L}\left[ f_2\left( t \right) \right] =F_1\left( s \right) \cdot F_2\left( s \right)</script><p>这个性质表明两个函数卷积的Laplace变换等于这两个函数Laplace变换乘积</p></blockquote><h2 id="五-卷积定义："><a href="#五-卷积定义：" class="headerlink" title="五.卷积定义："></a>五.卷积定义：</h2><blockquote><p>设有两个函数$f_1\left( t \right) ,f_2\left( t \right)$ ,称积分</p><script type="math/tex; mode=display">f_1\left( t \right) \ast f_2\left( t \right) =\int_{-\infty}^{+\infty}{f_1\left( \tau \right) f_2\left( t-\tau \right)}d\tau</script><p>为函数$f_1\left( x \right) ,f_2\left( x \right)$的卷积</p><p>若函数$f_1\left( t \right) ,f_2\left( t \right)$满足：当$t&lt;0$时，$f_1\left( t \right) =f_2\left( t \right) =0$,则有</p><script type="math/tex; mode=display">f_1\left( t \right) \ast f_2\left( t \right) =\int_0^t{f_1\left( \tau \right) f_2\left( t-\tau \right)}d\tau</script></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Integral transform </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表分离奇偶节点</title>
      <link href="/2020/05164341.html"/>
      <url>/2020/05164341.html</url>
      
        <content type="html"><![CDATA[<h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><blockquote><p>函数<code>readlist</code>从标准输入读入一系列正整数，按照读入顺序建立单链表。当读到<code>−1</code>时表示输入结束，函数应返回指向单链表头结点的指针。</p><p>函数<code>getodd</code>将单链表<code>L</code>中奇数值的结点分离出来，重新组成一个新的链表。返回指向新链表头指针，同时将<code>L</code>改为删除了奇数值结点后的链表的头指针</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>函数<code>readlist</code>不必说，就是一层循环，判断输入是否为<code>-1</code>,返回头指针。</p><p>函数<code>getodd</code>首先创建奇链表的头指针<code>jList</code>，遍历创建好的链表，遇到奇数节点，利用尾插法将奇数节点链接在<code>jList</code>上，偶数节点时，创建一个临时指针保存当前节点（遇到奇数节点时，临时指针就是当前节点的前序节点，原链表可以跨过此节点）。</p></blockquote><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code>struct ListNode *creatNode(int x){    struct ListNode *p = (struct ListNode *)malloc(sizeof(struct ListNode));    p-&gt;data = x;    p-&gt;next = NULL;    return p;}struct ListNode *readlist(){    int x;    scanf("%d", &amp;x);    struct ListNode *head = creatNode(x);    struct ListNode *pre = head;    scanf("%d", &amp;x);    while(x != -1){        struct ListNode *p = creatNode(x);        pre-&gt;next = p;        pre = p;        scanf("%d", &amp;x);    }    return head;}struct ListNode *getodd( struct ListNode **L ){    struct ListNode *jList = (struct ListNode *)malloc(sizeof(struct ListNode));    jList-&gt;next = NULL;    struct ListNode *jpre = jList;    while(*L &amp;&amp; (*L)-&gt;data % 2 == 1){        jpre-&gt;next = *L;        jpre = jpre-&gt;next;        *L = (*L)-&gt;next;    }    struct ListNode *oList = *L;    struct ListNode *opre = oList;    while (oList) {        if (oList-&gt;data % 2 == 1) {            jpre-&gt;next = oList;            jpre = jpre-&gt;next;            opre-&gt;next = oList-&gt;next;            oList = oList-&gt;next;        }        else {            opre = oList;            oList = oList-&gt;next;        }    }    jpre-&gt;next = NULL;    return jList-&gt;next;}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Data structure and algorithm </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
